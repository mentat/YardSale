<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>YardSale: xmlnode.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>xmlnode.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">    $Id: xmlnode.h,v 1.6 2004/05/10 02:25:33 thementat Exp $</span>
00003 <span class="comment"> </span>
00004 <span class="comment">    XMLNode - A XML DOM tree</span>
00005 <span class="comment">    </span>
00006 <span class="comment">    Original Copyright (C) 2001-2002  Henrik Abelsson &lt;henrik@abelsson.com&gt;</span>
00007 <span class="comment">    Copyright(C) 2003-2004 Jesse Lovelace &lt;jllovela@ncsu.edu&gt;</span>
00008 <span class="comment"> </span>
00009 <span class="comment">    This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment">    (at your option) any later version.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment">    GNU General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00020 <span class="comment">    along with this program; if not, write to the Free Software</span>
00021 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00022 <span class="comment"></span>
00023 <span class="comment">*/</span>
00024 <span class="preprocessor">#ifndef XMLNODE_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define XMLNODE_H</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;iostream&gt;</span>
00028 <span class="preprocessor">#include &lt;limits&gt;</span>
00029 <span class="preprocessor">#include &lt;string&gt;</span>
00030 <span class="preprocessor">#include &lt;vector&gt;</span>
00031 <span class="preprocessor">#include &lt;locale&gt;</span>
00032 <span class="preprocessor">#include &lt;map&gt;</span>
00033 
00034 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00035 
00036 <span class="keyword">class </span><a class="code" href="class_x_m_l_node.html">XMLNode</a>;
00037 <span class="preprocessor">#ifdef XMLNODE_USE_HASHMAP</span>
00038 <span class="preprocessor"></span><span class="comment">// Pulling in hash map</span>
00039 <span class="preprocessor">  #ifdef __GNUC__ // Fuck me this is the ugliest thing</span>
00040 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;ext/hash_map&gt;</span>
00041     <span class="keyword">namespace </span>__gnu_cxx
00042     {
00043       <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00044      
00045       <span class="keyword">template</span>&lt;&gt;
00046         <span class="keyword">struct </span>hash&lt;string&gt;
00047         {
00048           size_t operator()(<span class="keyword">const</span> string&amp; s)<span class="keyword"> const</span>
00049 <span class="keyword">          </span>{
00050             <span class="keyword">const</span> collate&lt;char&gt;&amp; c = use_facet&lt;collate&lt;char&gt; &gt;(locale::classic());
00051             <span class="keywordflow">return</span> c.hash(s.c_str(), s.c_str() + s.size());
00052           }
00053         };
00054     }
00055     <span class="keyword">using</span> <span class="keyword">namespace </span>__gnu_cxx;
00056 <span class="preprocessor">  #else      // ...  there are other compilers, right?</span>
00057 <span class="preprocessor"></span><span class="preprocessor">   #include &lt;ext/hash_map&gt;</span> <span class="comment">// MSOFT</span>
00058 <span class="preprocessor"> #endif</span>
00059 <span class="preprocessor"></span><span class="keyword">typedef</span> hash_multimap&lt;string, XMLNode&gt; NodeMap;
00060 <span class="keyword">typedef</span> hash_map&lt;string, string&gt; AttributeMap;
00061 <span class="preprocessor">#else // else use regular map</span>
00062 <span class="preprocessor"></span><span class="keyword">typedef</span> multimap&lt;string, XMLNode&gt; NodeMap;
00063 <span class="keyword">typedef</span> map&lt;string, string&gt; AttributeMap;    
00064 <span class="preprocessor">#endif</span>
00065 <span class="preprocessor"></span>    
00066 <span class="comment">// Allow users to derive a new exception base,</span>
00067 <span class="comment">//  this could be implemented as a template policy...</span>
00068 <span class="preprocessor">#ifndef XMLNODE_EXCEPTION_BASE</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#include &lt;exception&gt;</span>   
00070 <span class="preprocessor">#define XMLNODE_EXCEPTION_BASE std::exception</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00072 <span class="preprocessor"></span>    
00073 <span class="preprocessor">#define XMLNODE_DOUBLE_PRECISION    3</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define XMLNODE_DOUBLE_MAX_MANTISSA numeric_limits&lt;double&gt;::digits10</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define XMLNODE_THROW_NOTFOUND      0</span>
00076 <span class="preprocessor"></span>
00077 <span class="comment">// Master exception class for all XML    </span>
00078 <span class="keyword">class </span>XMLException: <span class="keyword">public</span> XMLNODE_EXCEPTION_BASE {
00079  <span class="keyword">public</span>:
00080         
00081     <span class="keyword">explicit</span> XMLException(<span class="keyword">const</span> string&amp; err):m_what(err) {}
00082  
00083     <span class="keyword">virtual</span> ~XMLException() <span class="keywordflow">throw</span>() {}
00084     <span class="keyword">const</span> <span class="keywordtype">char</span> *what() <span class="keyword">const</span> <span class="keywordflow">throw</span>() {<span class="keywordflow">return</span> (m_what.c_str());}    
00085     <span class="keywordtype">void</span> SetWhat(<span class="keyword">const</span> string &amp;s) { m_what = s; } 
00086     <span class="keyword">const</span> string&amp; GetWhat()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_what; }
00087     
00088  <span class="keyword">private</span>:
00089     string m_what;
00090  };
00091 
<a name="l00123"></a><a class="code" href="class_x_m_l_node.html">00123</a> <span class="keyword">class </span><a class="code" href="class_x_m_l_node.html">XMLNode</a>
00124 {
00125 <span class="keyword">public</span>:
00126 
<a name="l00130"></a><a class="code" href="class_x_m_l_node_1_1_invalid_child.html">00130</a>     <span class="keyword">class </span><a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>: <span class="keyword">public</span> XMLException
00131     {
00132     <span class="keyword">public</span>:
00133         <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="keyword">const</span> string&amp; error): XMLException(error) {}
00134     };
00135 
<a name="l00139"></a><a class="code" href="class_x_m_l_node_1_1_parse_failure.html">00139</a>     <span class="keyword">class </span><a class="code" href="class_x_m_l_node_1_1_parse_failure.html">ParseFailure</a>: <span class="keyword">public</span> XMLException
00140     {
00141     <span class="keyword">public</span>:
00142         <a class="code" href="class_x_m_l_node_1_1_parse_failure.html">ParseFailure</a>(<span class="keyword">const</span> string&amp; error): XMLException(error) {}
00143     };
00144     
00145     <span class="comment">// Cannot convert string to desired type</span>
00146     <span class="keyword">class </span>RangeOverflow: <span class="keyword">public</span> XMLException
00147     {
00148     <span class="keyword">public</span>:
00149         RangeOverflow(<span class="keyword">const</span> string&amp; error): XMLException(error) {}
00150     };
00151 
00153     <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>();
00154     
00155     <span class="keyword">enum</span> Resource { File, Str };
00156     
00161     <span class="keyword">explicit</span> <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>(<span class="keyword">const</span> string&amp; id, Resource res = Str);
00162     
00168     <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>(<span class="keyword">const</span> string&amp; name, <span class="keyword">const</span> string&amp; data);
00169     
00174     <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>(<span class="keyword">const</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;other);
00175 
00176     <span class="keyword">virtual</span> ~<a class="code" href="class_x_m_l_node.html">XMLNode</a>();
00177 
<a name="l00179"></a><a class="code" href="class_x_m_l_node.html#a5">00179</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> string&amp; <a class="code" href="class_x_m_l_node.html#a5">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o2">m_name</a>; }
00180     
<a name="l00182"></a><a class="code" href="class_x_m_l_node.html#a6">00182</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> string <a class="code" href="class_x_m_l_node.html#a6">type</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"xml"</span>; }
00183 
<a name="l00185"></a><a class="code" href="class_x_m_l_node.html#a7">00185</a>     <span class="keyword">const</span> string &amp;<a class="code" href="class_x_m_l_node.html#a7">data</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o3">m_data</a>; }
00186    
00187     <span class="comment">/* </span>
00188 <span class="comment">    * Return all properties</span>
00189 <span class="comment">    */</span>
00190     AttributeMap&amp; properties();
00191 
00192     <span class="comment">/*</span>
00193 <span class="comment">    * Return all properties (read only)</span>
00194 <span class="comment">    */</span>
00195     <span class="keyword">const</span> AttributeMap&amp; const_properties() <span class="keyword">const</span>;
00196 
00197     <span class="comment">/* Return a single property */</span>
00198     <span class="keyword">const</span> string property(<span class="keyword">const</span> string &amp;name) <span class="keyword">const</span>;
00199 
00200     <span class="comment">/* </span>
00201 <span class="comment">    * Return property as an integer if possible, otherwise 0.</span>
00202 <span class="comment">    */</span>
00203     <span class="keywordtype">long</span> intProperty(<span class="keyword">const</span> string &amp;name) <span class="keyword">const</span>;
00204 
00205     <span class="comment">/*</span>
00206 <span class="comment">    * True if the node has a child with the specified name</span>
00207 <span class="comment">    * @param name name of tag to look for</span>
00208 <span class="comment">    * @param n how many tags are required (n=2 means there </span>
00209 <span class="comment">     *   has to be two children with the specified name) </span>
00210 <span class="comment">     */</span>
00211     <span class="keywordtype">bool</span> hasChild(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">int</span> n=1) <span class="keyword">const</span>;
00212 
00214     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_x_m_l_node.html#a13">numChildren</a>(<span class="keyword">const</span> string &amp;name) <span class="keyword">const</span>;
00215 
00222    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00223"></a><a class="code" href="class_x_m_l_node.html#a14">00223</a>     vector&lt;T&gt; <a class="code" href="class_x_m_l_node.html#a14">XMLNode::children</a>() 
00224     { 
00225         vector&lt;T&gt; ret;
00226         <span class="keywordflow">for</span> (NodeMap::iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.begin();
00227                 it != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end(); it++)
00228            ret.push_back(T(it-&gt;second));
00229         
00230         <span class="keywordflow">return</span> ret;
00231     }
00232 
00234     vector&lt;XMLNode&gt; const_children() <span class="keyword">const</span>;
00235     
<a name="l00237"></a><a class="code" href="class_x_m_l_node.html#a16">00237</a>     NodeMap&amp; getMap()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_xmlData-&gt;m_children; }
00238     
00243     <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; child(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index=0);
00244     
00249     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00250"></a><a class="code" href="class_x_m_l_node.html#a18">00250</a>     vector&lt;T&gt; children(<span class="keyword">const</span> string&amp; name)
00251     {
00252         vector&lt;T&gt; ret;
00253         pair&lt;NodeMap::iterator, NodeMap::iterator&gt; p(m_xmlData-&gt;m_children.equal_range(name));
00254     
00255         <span class="keywordflow">while</span> (p.first != m_xmlData-&gt;m_children.end())
00256             ret.push_back(T((p.first++)-&gt;second));
00257         
00258         <span class="keywordflow">return</span> ret;   
00259     }
00260     
00267     <a class="code" href="class_x_m_l_node.html">XMLNode</a> child(<span class="keyword">const</span> string&amp; name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0) <span class="keyword">const</span>;
00268 
<a name="l00270"></a><a class="code" href="class_x_m_l_node.html#a20">00270</a>     <span class="keyword">inline</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;setName(<span class="keyword">const</span> string &amp;name) { m_xmlData-&gt;m_name = name; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00271 
<a name="l00273"></a><a class="code" href="class_x_m_l_node.html#a21">00273</a>     <span class="keyword">inline</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;setData(<span class="keyword">const</span> string &amp;data) { m_xmlData-&gt;m_data = data; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00274 
<a name="l00276"></a><a class="code" href="class_x_m_l_node.html#a22">00276</a>     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;setCData(<span class="keyword">const</span> string &amp;data) { m_xmlData-&gt;data_is_cdata=<span class="keyword">true</span>; m_xmlData-&gt;m_data = data; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00277 
00279     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;setProperty(<span class="keyword">const</span> string &amp;name, <span class="keyword">const</span> string &amp;value);
00281     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;setProperty(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">int</span> value);
00282 
00284     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;addChild( <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;node);
00285 
00287     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;addChild(<span class="keyword">const</span> string &amp;name, <span class="keyword">const</span> string &amp;data=<span class="stringliteral">""</span>);
00288 
00294     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;delChild(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index=0);
00295 
00297     <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; moveChild(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newIndex);
00298 
00304     <span class="keyword">friend</span> ostream&amp; operator&lt;&lt;(ostream &amp;o, <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;n);
00305 
00311     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;operator&lt;&lt;(<span class="keyword">const</span> string &amp;str) <span class="keywordflow">throw</span>(ParseFailure);
00312 
00319     <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;other);
00320 
00321     <span class="comment">// Implicitly convert to string.</span>
00322     operator string() <span class="keyword">const</span>;
00323 
00325     string&amp; operator[](<span class="keyword">const</span> string &amp;name);
00326 
00332     string operator[](<span class="keyword">const</span> string &amp;name) <span class="keyword">const</span>;
00333 
00334     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="class_x_m_l_parser.html">XMLParser</a>;
00335         
00338     <span class="keyword">static</span> <span class="keywordtype">long</span> ToLong(<span class="keyword">const</span> string&amp; str);
00341     <span class="keyword">static</span> <span class="keywordtype">int</span> ToInt(<span class="keyword">const</span> string&amp; str);
00344     <span class="keyword">static</span> <span class="keywordtype">double</span> ToDouble(<span class="keyword">const</span> string&amp; str);
00345     
00351     <span class="keyword">static</span> string ToStr(<span class="keywordtype">long</span> numeric);
00358     <span class="keyword">static</span> string ToStr(<span class="keywordtype">double</span> floating, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> precision);
00359     
00360 <span class="keyword">protected</span>:
00361 
<a name="l00365"></a><a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">00365</a>     <span class="keyword">class </span><a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">XMLNodeData</a>
00366     {
00367     <span class="keyword">public</span>:
00368         <a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">XMLNodeData</a>()
00369         { refCount=1; <span class="comment">/*cout &lt;&lt; (unsigned long)this &lt;&lt; " created." &lt;&lt; endl;*/</span> }
00370 
00371         ~<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">XMLNodeData</a>() { <span class="comment">/*cout &lt;&lt; (unsigned long)this &lt;&lt; " deleting." &lt;&lt; endl;*/</span> }
00372         
<a name="l00375"></a><a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a2">00375</a>         <span class="keyword">inline</span> <span class="keywordtype">void</span> ref() { refCount++; }
00376 
<a name="l00379"></a><a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a3">00379</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> deref() 
00380         { <span class="keywordflow">if</span> (--refCount == 0) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">return</span> <span class="keyword">false</span>; }
00381         
00382         NodeMap m_children;
00383         AttributeMap m_properties;
00384         
00385         string m_name;
00386         string m_data;
00387 
00388     <span class="keyword">private</span>:
00389         <span class="keywordtype">int</span> refCount;
00390 
00391     <span class="keyword">public</span>:        
00392         <span class="keywordtype">bool</span> data_is_cdata;
00393         <span class="keywordtype">bool</span> oneline;
00394     };
00395     
00396     XMLNodeData *m_xmlData;
00397 };
00398         
00399 <span class="preprocessor">#endif // !GM_XMLNODE_H</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 9 23:07:58 2004 for YardSale by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
