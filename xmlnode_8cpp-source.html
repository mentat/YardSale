<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>YardSale: xmlnode.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>xmlnode.cpp</h1><div class="fragment"><pre>00001 <span class="comment">// --*-c++-*--</span>
00002 <span class="comment">/*</span>
00003 <span class="comment">    $Id: xmlnode.cpp,v 1.4 2004/04/24 18:16:59 thementat Exp $</span>
00004 <span class="comment"> </span>
00005 <span class="comment">    GNU Messenger - The secure instant messenger</span>
00006 <span class="comment">    Copyright (C) 2001-2002  Henrik Abelsson &lt;henrik@abelsson.com&gt;</span>
00007 <span class="comment"> </span>
00008 <span class="comment">    This program is free software; you can redistribute it and/or modify</span>
00009 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00010 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00011 <span class="comment">    (at your option) any later version.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    This program is distributed in the hope that it will be useful,</span>
00014 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00015 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00016 <span class="comment">    GNU General Public License for more details.</span>
00017 <span class="comment"></span>
00018 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00019 <span class="comment">    along with this program; if not, write to the Free Software</span>
00020 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00021 <span class="comment"></span>
00022 <span class="comment">*/</span>
00023 
00024 <span class="preprocessor">#include &lt;map&gt;</span>
00025 <span class="preprocessor">#include &lt;string&gt;</span>
00026 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00027 <span class="preprocessor">#include &lt;sstream&gt;</span>
00028 <span class="preprocessor">#include &lt;cstdlib&gt;</span> <span class="comment">// for atol</span>
00029 <span class="preprocessor">#include &lt;cerrno&gt;</span> <span class="comment">// for atol as well</span>
00030 
00031 <span class="preprocessor">#include "xmlnode.h"</span>
00032 <span class="preprocessor">#include "xml.h"</span>
00033 
00034 <span class="preprocessor">#ifndef LOG_DEBUG</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#ifdef DEBUG</span>
00036 <span class="preprocessor"></span><span class="preprocessor"> #ifdef WIN32</span>
00037 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;fstream&gt;</span>
00038   <span class="keyword">static</span> ofstream debugOut(<span class="stringliteral">"xmlnode_debug.txt"</span>);
00039 <span class="preprocessor">  #define LOG_DEBUG(str) debugOut &lt;&lt; str &lt;&lt; endl;</span>
00040 <span class="preprocessor"></span><span class="preprocessor"> #else</span>
00041 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;iostream&gt;</span>
00042 <span class="preprocessor">  #define LOG_DEBUG(str) cout &lt;&lt; str &lt;&lt; endl;</span>
00043 <span class="preprocessor"></span><span class="preprocessor"> #endif</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00045 <span class="preprocessor"></span><span class="preprocessor"> #define LOG_DEBUG(str) {}</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#endif // LOG_DEBUG</span>
00048 <span class="preprocessor"></span>     
00049 <span class="preprocessor">#if 0</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#ifdef _UNICODE</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#undef string</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define string basic_string&lt;wchar_t&gt;</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00055 <span class="preprocessor"></span>
00056 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00057 
<a name="l00058"></a><a class="code" href="class_x_m_l_node.html#a0">00058</a> <a class="code" href="class_x_m_l_node.html#a0">XMLNode::XMLNode</a>()
00059 {
00060     m_xmlData=<span class="keyword">new</span> <a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">XMLNodeData</a>();
00061     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o4">data_is_cdata</a>=<span class="keyword">false</span>;
00062     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o5">oneline</a>=<span class="keyword">false</span>;
00063 }
00064 
<a name="l00065"></a><a class="code" href="class_x_m_l_node.html#a3">00065</a> <a class="code" href="class_x_m_l_node.html#a0">XMLNode::XMLNode</a>(<span class="keyword">const</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;other)
00066 {
00067     other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a2">ref</a>();
00068     m_xmlData=other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>;
00069 }
00070 
<a name="l00071"></a><a class="code" href="class_x_m_l_node.html#a2">00071</a> <a class="code" href="class_x_m_l_node.html#a0">XMLNode::XMLNode</a>(<span class="keyword">const</span> string&amp; name, <span class="keyword">const</span> string&amp; data)
00072 {
00073     m_xmlData=<span class="keyword">new</span> <a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html">XMLNodeData</a>();
00074     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o4">data_is_cdata</a>=<span class="keyword">false</span>;
00075     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o5">oneline</a>=<span class="keyword">false</span>;
00076     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o2">m_name</a> = name;
00077     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o3">m_data</a> = data;
00078 }
00079     
<a name="l00080"></a><a class="code" href="class_x_m_l_node.html#a1">00080</a> <a class="code" href="class_x_m_l_node.html#a0">XMLNode::XMLNode</a>(<span class="keyword">const</span> string&amp; id, Resource res)
00081 {
00082     <span class="keywordflow">try</span> 
00083     {
00084         <span class="keywordflow">if</span> (res == File)
00085         {
00086             <a class="code" href="class_x_m_l_parser.html">XMLParser</a> p(id,XMLParser::File);
00087             p.<a class="code" href="class_x_m_l_parser.html#a6">get_root</a>().<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a2">ref</a>();
00088             m_xmlData = p.<a class="code" href="class_x_m_l_parser.html#a6">get_root</a>().<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>;
00089         }
00090         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (res == Str)
00091         {
00092             <a class="code" href="class_x_m_l_parser.html">XMLParser</a> p(id, XMLParser::String);
00093             p.<a class="code" href="class_x_m_l_parser.html#a6">get_root</a>().<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a2">ref</a>();
00094             m_xmlData = p.<a class="code" href="class_x_m_l_parser.html#a6">get_root</a>().<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>;
00095         }
00096        
00097     }
00098     <span class="keywordflow">catch</span>(<a class="code" href="class_x_m_l_parser_1_1_parse_failure.html">XMLParser::ParseFailure</a> &amp;e)
00099     {
00100         <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_parse_failure.html">ParseFailure</a>(e.what());
00101     }   
00102 }
00103 
00104 XMLNode::~XMLNode()
00105 {
00106     <span class="keywordflow">if</span> ((m_xmlData) &amp;&amp; m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a3">deref</a>())
00107     {
00108         <span class="keyword">delete</span> m_xmlData;
00109         m_xmlData=0;
00110     }
00111 }
00112 
00113 <span class="keywordtype">bool</span> XMLNode::hasChild(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">int</span> n)<span class="keyword"> const</span>
00114 <span class="keyword"></span>{
00115     <span class="comment">// multimap: logarithmic</span>
00116     <span class="comment">// hash_mmap: Average is constant time. Worst is linear in the size of the container.</span>
00117     <span class="keywordflow">if</span> (m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.find(name) == m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end())
00118         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00119     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00120 }
00121 
<a name="l00122"></a><a class="code" href="class_x_m_l_node.html#a13">00122</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_x_m_l_node.html#a13">XMLNode::numChildren</a>(<span class="keyword">const</span> string &amp;name)<span class="keyword"> const</span>
00123 <span class="keyword"></span>{
00124     <span class="comment">// multimap:  O(log(size()) + count(k))</span>
00125     <span class="comment">// hash_mmap: Average is O(count(k)). Worst is linear in the size of the container.</span>
00126     <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.count(name);
00127 }
00128 
00129 <span class="keyword">const</span> string XMLNode::property(<span class="keyword">const</span> string &amp;name)<span class="keyword"> const</span>
00130 <span class="keyword"></span>{
00131     <span class="comment">// average is constant time, worst is linear in size of container</span>
00132     AttributeMap::const_iterator it=m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.find(name);
00133     
00134     <span class="keywordflow">if</span> (it == m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.end())
00135         <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00136     <span class="keywordflow">else</span>
00137         <span class="keywordflow">return</span> it-&gt;second;
00138 }
00139 
<a name="l00140"></a><a class="code" href="class_x_m_l_node.html#e0">00140</a> <span class="keywordtype">long</span> <a class="code" href="class_x_m_l_node.html#e0">XMLNode::ToLong</a>(<span class="keyword">const</span> string&amp; str) 
00141 {
00142     <span class="keywordtype">long</span> convert;
00143     errno = 0;
00144     convert = atol(str.c_str());
00145     
00146     <span class="keywordflow">if</span> (errno == ERANGE)
00147         <span class="keywordflow">throw</span> RangeOverflow(<span class="stringliteral">"The string cannot be represented in the intended result type."</span>);
00148     
00149     <span class="keywordflow">return</span> convert;
00150 }
00151 
<a name="l00152"></a><a class="code" href="class_x_m_l_node.html#e1">00152</a> <span class="keywordtype">int</span> <a class="code" href="class_x_m_l_node.html#e1">XMLNode::ToInt</a>(<span class="keyword">const</span> string&amp; str)
00153 {
00154     <span class="keywordtype">int</span> convert;
00155     errno = 0;
00156     convert = atoi(str.c_str());
00157     
00158     <span class="keywordflow">if</span> (errno == ERANGE)
00159         <span class="keywordflow">throw</span> RangeOverflow(<span class="stringliteral">"The string cannot be represented in the intended result type."</span>);
00160     
00161     <span class="keywordflow">return</span> convert;
00162 }
00163 
<a name="l00164"></a><a class="code" href="class_x_m_l_node.html#e2">00164</a> <span class="keywordtype">double</span> <a class="code" href="class_x_m_l_node.html#e2">XMLNode::ToDouble</a>(<span class="keyword">const</span> string&amp; str)
00165 {    
00166     <span class="keywordtype">double</span> convert;
00167     errno = 0;
00168     convert = atof(str.c_str());
00169     
00170     <span class="keywordflow">if</span> (errno == ERANGE)
00171         <span class="keywordflow">throw</span> RangeOverflow(<span class="stringliteral">"The string cannot be represented in the intended result type."</span>);
00172     
00173     <span class="keywordflow">return</span> convert;
00174 }
00175 
<a name="l00176"></a><a class="code" href="class_x_m_l_node.html#e3">00176</a> string <a class="code" href="class_x_m_l_node.html#e3">XMLNode::ToStr</a>(<span class="keywordtype">long</span> numeric)
00177 {
00178     stringstream ret;
00179     ret &lt;&lt; numeric;
00180     LOG_DEBUG(<span class="stringliteral">"ToStr: "</span> &lt;&lt; ret.str());
00181     <span class="keywordflow">return</span> ret.str();
00182 }
00183 
<a name="l00184"></a><a class="code" href="class_x_m_l_node.html#e4">00184</a> string <a class="code" href="class_x_m_l_node.html#e3">XMLNode::ToStr</a>(<span class="keywordtype">double</span> floating, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> precision)
00185 {
00186     stringstream ret;
00187     ret.setf(ios_base::fixed, ios_base::floatfield);
00188     ret.precision(precision);
00189     <span class="comment">// precision is total number of digits in iomanip! :(</span>
00190     ret &lt;&lt; floating;
00191     LOG_DEBUG(<span class="stringliteral">"ToStrD: "</span> &lt;&lt; ret.str());
00192     <span class="keywordflow">return</span> ret.str();
00193 }
00194 
00195 <span class="keywordtype">long</span> XMLNode::intProperty(<span class="keyword">const</span> string &amp;name)<span class="keyword"> const</span>
00196 <span class="keyword"></span>{
00197     <span class="comment">// average is constant time, worst is linear in size of container</span>
00198     AttributeMap::const_iterator it=m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.find(name);
00199     
00200     <span class="keywordflow">if</span> (it==m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.end())
00201         <span class="keywordflow">return</span> 0;
00202     <span class="keywordflow">else</span>
00203         <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#e0">ToLong</a>(it-&gt;second.c_str());
00204 }
00205 <span class="preprocessor">#if 0</span>
00206 <span class="preprocessor"></span>vector&lt;XMLNode&gt; <a class="code" href="class_x_m_l_node.html#a14">XMLNode::children</a>(<span class="keyword">const</span> string&amp; name)
00207 {
00208     vector&lt;XMLNode&gt; ret;
00209     pair&lt;NodeMap::iterator, NodeMap::iterator&gt; p(m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.equal_range(name));
00210 
00211     <span class="keywordflow">while</span> (p.first != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end())
00212         ret.push_back((p.first++)-&gt;second);
00213     
00214     <span class="keywordflow">return</span> ret;   
00215 }
00216 <span class="preprocessor">#endif</span>
00217 <span class="preprocessor"></span>
00218 <span class="preprocessor">#if 0</span>
00219 <span class="preprocessor"></span>vector&lt;XMLNode&gt; <a class="code" href="class_x_m_l_node.html#a14">XMLNode::children</a>() 
00220 { 
00221     vector&lt;XMLNode&gt; ret;
00222     <span class="keywordflow">for</span> (NodeMap::iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.begin();
00223             it != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end(); it++)
00224        ret.push_back(it-&gt;second);
00225     
00226     <span class="keywordflow">return</span> ret;
00227 }
00228 <span class="preprocessor">#endif</span>
00229 <span class="preprocessor"></span>
00230 
<a name="l00233"></a><a class="code" href="class_x_m_l_node.html#a15">00233</a> vector&lt;XMLNode&gt; <a class="code" href="class_x_m_l_node.html#a15">XMLNode::const_children</a>()<span class="keyword"> const </span>
00234 <span class="keyword"></span>{    
00235    vector&lt;XMLNode&gt; ret;
00236     <span class="keywordflow">for</span> (NodeMap::const_iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.begin();
00237             it != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end(); it++)
00238        ret.push_back(it-&gt;second);
00239     
00240     <span class="keywordflow">return</span> ret;
00241 }
00242 
00243 
<a name="l00244"></a><a class="code" href="class_x_m_l_node.html#a17">00244</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a17">XMLNode::child</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)
00245 {
00246     NodeMap::iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.find(name);
00247     
00248     <span class="keywordflow">if</span> (it == m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end())
00249         <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#a25">addChild</a>(name, <span class="stringliteral">""</span>);
00250  
00251     <span class="keywordflow">if</span> (n == 0)
00252     {
00253         LOG_DEBUG(<span class="stringliteral">"Found at n=0"</span>);
00254         <span class="keywordflow">return</span> it-&gt;second;
00255     }
00256      
00257     <span class="comment">// Logarithmic calls (lower_bound and upper_bound)</span>
00258     <span class="comment">// if using multimap, or constant if hash_multimap</span>
00259     
00260     pair&lt;NodeMap::iterator, NodeMap::iterator&gt; p(m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.equal_range(name));
00261     
00262     <span class="keywordflow">while</span>( (n &gt; 0) &amp;&amp; (++p.first != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end()) ) {
00263         <span class="keywordflow">if</span> (--n == 0)
00264             <span class="keywordflow">return</span> (p.first)-&gt;second;
00265     }
00266     LOG_DEBUG(<span class="stringliteral">"No child of that key at index"</span>);
00267     <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#a25">addChild</a>(name, <span class="stringliteral">""</span>);
00268 }
00269 
<a name="l00270"></a><a class="code" href="class_x_m_l_node.html#a19">00270</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a> <a class="code" href="class_x_m_l_node.html#a17">XMLNode::child</a>(<span class="keyword">const</span> string&amp; name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)<span class="keyword"> const</span>
00271 <span class="keyword"></span>{
00272     LOG_DEBUG(<span class="stringliteral">"Const child."</span>);
00273     NodeMap::const_iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.find(name);
00274     
00275     <span class="keywordflow">if</span> (it == m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end())
00276 <span class="preprocessor">#if (XMLNODE_THROW_NOTFOUND)</span>
00277 <span class="preprocessor"></span>    <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="stringliteral">"Invalid child"</span>);
00278 <span class="preprocessor">#else</span>
00279 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>();
00280 <span class="preprocessor">#endif</span>
00281 <span class="preprocessor"></span>    
00282     <span class="keywordflow">if</span> (n == 0)
00283     {
00284         LOG_DEBUG(<span class="stringliteral">"Found at n=0"</span>);
00285         <span class="keywordflow">return</span> it-&gt;second;
00286     }
00287      
00288     <span class="comment">// Logarithmic calls (lower_bound and upper_bound)</span>
00289     <span class="comment">// if using multimap, or constant if hash_multimap</span>
00290     
00291     pair&lt;NodeMap::const_iterator, NodeMap::const_iterator&gt; p(m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.equal_range(name));
00292     
00293     <span class="keywordflow">while</span>( (n &gt; 0) &amp;&amp; (++p.first != m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end()) ) {
00294         <span class="keywordflow">if</span> (--n == 0)
00295             <span class="keywordflow">return</span> (p.first)-&gt;second;
00296     }
00297     LOG_DEBUG(<span class="stringliteral">"No child of that key at index"</span>);
00298 <span class="preprocessor">#if (XMLNODE_THROW_NOTFOUND)</span>
00299 <span class="preprocessor"></span>    <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="stringliteral">"Invalid child"</span>);
00300 <span class="preprocessor">#else</span>
00301 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#a0">XMLNode</a>();
00302 <span class="preprocessor">#endif</span>
00303 <span class="preprocessor"></span>    
00304 }
00305 
<a name="l00306"></a><a class="code" href="class_x_m_l_node.html#a23">00306</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a23">XMLNode::setProperty</a>(<span class="keyword">const</span> string &amp;name, <span class="keyword">const</span> string &amp;value)
00307 {
00308     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>[name] = value;
00309     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00310 }
00311 
<a name="l00312"></a><a class="code" href="class_x_m_l_node.html#a24">00312</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a23">XMLNode::setProperty</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">int</span> value)
00313 {
00314     stringstream foo;
00315     foo &lt;&lt; value;
00316     <span class="keywordflow">return</span> <a class="code" href="class_x_m_l_node.html#a23">setProperty</a>(name, foo.str());
00317 }
00318 
<a name="l00319"></a><a class="code" href="class_x_m_l_node.html#a26">00319</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a25">XMLNode::addChild</a>(<span class="keyword">const</span> string &amp;name, <span class="keyword">const</span> string &amp;data)
00320 {
00321     <a class="code" href="class_x_m_l_node.html">XMLNode</a> tmp(name, data);
00322     
00323     <span class="comment">// multimap: Average complexity for insert element is at most logarithmic.</span>
00324     <span class="comment">// hash_mmap: </span>
00325     <span class="keywordflow">return</span> ((m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.insert(NodeMap::value_type(name, tmp)))-&gt;second);
00326 }
00327 
<a name="l00329"></a><a class="code" href="class_x_m_l_node.html#a25">00329</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;<a class="code" href="class_x_m_l_node.html#a25">XMLNode::addChild</a>(<a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; node) 
00330 { 
00331     <span class="comment">// ARG This is wrong according to the SGI docs, DAMNIT</span>
00332     <span class="comment">// it should return a pair&lt;X::iterator, bool&gt; FUCK</span>
00333     <span class="keywordflow">return</span> ((m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.insert(NodeMap::value_type(node.<a class="code" href="class_x_m_l_node.html#a5">name</a>(), node)))-&gt;second);
00334 }
00335 
<a name="l00336"></a><a class="code" href="class_x_m_l_node.html#a27">00336</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a27">XMLNode::delChild</a>(<span class="keyword">const</span> string &amp;name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)
00337 {
00338     pair&lt;NodeMap::iterator, NodeMap::iterator&gt; p(m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.equal_range(name));
00339     
00340     <span class="comment">// item not found</span>
00341     <span class="keywordflow">if</span> (p.first == m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.end())
00342 <span class="preprocessor">#if (XMLNODE_THROW_NOTFOUND)</span>
00343 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="stringliteral">"Invalid child"</span>);
00344 <span class="preprocessor">#else</span>
00345 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00346 <span class="preprocessor">#endif</span>
00347 <span class="preprocessor"></span>    
00348     <span class="keywordflow">if</span> (n == 0)
00349     {
00350         m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.erase(p.first);
00351         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00352     }
00353     
00354     <span class="comment">// both: at most O(count(n))</span>
00355     <span class="keywordflow">while</span>( (n &gt; 0) &amp;&amp; (p.first != p.second) ) {
00356         p.first++;
00357         <span class="keywordflow">if</span> (--n == 0)
00358         {
00359             m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.erase(p.first);
00360             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00361         }
00362     }
00363     
00364 <span class="preprocessor">#if (XMLNODE_THROW_NOTFOUND)</span>
00365 <span class="preprocessor"></span>        <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="stringliteral">"Invalid child"</span>);
00366 <span class="preprocessor">#else</span>
00367 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00368 <span class="preprocessor">#endif  </span>
00369 <span class="preprocessor"></span>}
00370 
00371 <span class="preprocessor">#if 0</span>
00372 <span class="preprocessor"></span><a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; <a class="code" href="class_x_m_l_node.html#a28">XMLNode::moveChild</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newIndex)
00373 {
00374 
00375     <span class="keywordflow">if</span> ( (index &gt;= m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.size()) || (newIndex &gt; m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.size()) )
00376         <span class="keywordflow">throw</span> XMLException(<span class="stringliteral">"Array out of bounds"</span>);
00377 
00378     <span class="comment">// account for idiots moving to same place</span>
00379     <span class="keywordflow">if</span> (index == newIndex)
00380         <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>[index];
00381 
00382     vector&lt;XMLNode&gt;::iterator it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.begin();
00383 
00384     <span class="comment">// account for index before newIndex</span>
00385     <span class="keywordflow">if</span> (index &lt; newIndex)
00386         newIndex--;
00387 
00388     <span class="keywordflow">while</span>(index-- != 0)
00389         it++;
00390 
00391     <a class="code" href="class_x_m_l_node.html">XMLNode</a> tmp(*it);
00392 
00393     m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.erase(it);
00394 
00395     it = m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.begin();
00396     
00397     <span class="keywordflow">while</span> (newIndex-- != 0)
00398         it++;
00399 
00400     <span class="keywordflow">return</span> *(m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o0">m_children</a>.insert(it, tmp));
00401     
00402 }
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>
00405 XMLNode::operator string()<span class="keyword"> const</span>
00406 <span class="keyword"></span>{
00407     string str;
00408     XMLParser::printTag(*<span class="keyword">this</span>,str);
00409     <span class="keywordflow">return</span> str;
00410 }
00411 
00412 AttributeMap&amp; XMLNode::properties() 
00413 { 
00414     <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>; 
00415 }
00416 
00417     <span class="comment">/*</span>
00418 <span class="comment">    * Return all properties (read only)</span>
00419 <span class="comment">    */</span>
00420 <span class="keyword">const</span> AttributeMap&amp; XMLNode::const_properties()<span class="keyword"> const </span>
00421 <span class="keyword"></span>{ 
00422     <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>; 
00423 }
00424 
<a name="l00425"></a><a class="code" href="class_x_m_l_node.html#a32">00425</a> string&amp; <a class="code" href="class_x_m_l_node.html#a32">XMLNode::operator[]</a>(<span class="keyword">const</span> string &amp;name)
00426 {
00427     <span class="keywordflow">return</span> m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>[name];
00428 }
00429 
<a name="l00430"></a><a class="code" href="class_x_m_l_node.html#a33">00430</a> string <a class="code" href="class_x_m_l_node.html#a32">XMLNode::operator[]</a>(<span class="keyword">const</span> string &amp;name)<span class="keyword"> const</span>
00431 <span class="keyword"></span>{
00432 
00433     AttributeMap::const_iterator it=m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.find(name);
00434 
00435     <span class="keywordflow">if</span> (it==m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#o1">m_properties</a>.end())
00436         <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_invalid_child.html">InvalidChild</a>(<span class="stringliteral">"The specified child does not exist."</span>);
00437     <span class="keywordflow">else</span>
00438         <span class="keywordflow">return</span> it-&gt;second;
00439 }
00440 
<a name="l00441"></a><a class="code" href="class_x_m_l_node.html#n1">00441</a> ostream &amp;operator&lt;&lt;(ostream &amp;o, <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;n)
00442 {
00443     string str;
00444 
00445     XMLParser::printTag(n,str);
00446     o &lt;&lt; str;
00447 
00448     <span class="keywordflow">return</span> o;
00449 }
00450 
<a name="l00451"></a><a class="code" href="class_x_m_l_node.html#a29">00451</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;<a class="code" href="class_x_m_l_node.html#n1">XMLNode::operator&lt;&lt;</a>(<span class="keyword">const</span> string &amp;str) <span class="keywordflow">throw</span> (<a class="code" href="class_x_m_l_node_1_1_parse_failure.html">ParseFailure</a>)
00452 {
00453     
00454     <span class="keywordflow">try</span> 
00455     {
00456         <a class="code" href="class_x_m_l_parser.html">XMLParser</a> p(str);
00457         *<span class="keyword">this</span> = p.<a class="code" href="class_x_m_l_parser.html#a6">get_root</a>();
00458     }
00459     <span class="keywordflow">catch</span>(<a class="code" href="class_x_m_l_parser_1_1_parse_failure.html">XMLParser::ParseFailure</a> &amp;e)
00460     {
00461         <span class="keywordflow">throw</span> <a class="code" href="class_x_m_l_node_1_1_parse_failure.html">ParseFailure</a>(e.what());
00462     }
00463     <span class="keywordflow">catch</span>(...)
00464     {
00465         LOG_DEBUG(<span class="stringliteral">"Unexpected exception from parse failure."</span>);
00466         <span class="keywordflow">throw</span> XMLException(<span class="stringliteral">"Unexpected exception from parse failure."</span>);
00467     }   
00468     
00469     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00470 }
00471 
<a name="l00472"></a><a class="code" href="class_x_m_l_node.html#a30">00472</a> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;<a class="code" href="class_x_m_l_node.html#a30">XMLNode::operator=</a>(<span class="keyword">const</span> <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;other)
00473 {
00474     <span class="keywordflow">if</span> (!other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>)
00475         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00476 
00477     <span class="keywordflow">if</span> (other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a> == m_xmlData)
00478         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00479     
00482     <span class="keywordflow">if</span> (other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>)
00483         other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a2">ref</a>();
00484                
00485     <span class="keywordflow">if</span> (m_xmlData &amp;&amp; m_xmlData-&gt;<a class="code" href="class_x_m_l_node_1_1_x_m_l_node_data.html#a3">deref</a>())
00486     {
00487         <span class="keyword">delete</span> m_xmlData;
00488         m_xmlData=0;
00489     }
00490     
00491     m_xmlData=other.<a class="code" href="class_x_m_l_node.html#p0">m_xmlData</a>;
00492     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00493 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 9 23:07:57 2004 for YardSale by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
