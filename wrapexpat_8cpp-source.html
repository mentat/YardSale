<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>YardSale: wrapexpat.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>wrapexpat.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;iostream&gt;</span>
00002 <span class="preprocessor">#include &lt;sstream&gt;</span>
00003 
00004 <span class="preprocessor">#include "wrapexpat.h"</span>
00005 <span class="preprocessor">#include "expat.h"</span>
00006 
00007 <span class="preprocessor">#ifndef LOG_DEBUG</span>
00008 <span class="preprocessor"></span><span class="preprocessor">#ifdef DEBUG</span>
00009 <span class="preprocessor"></span><span class="preprocessor"> #ifdef WIN32</span>
00010 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;fstream&gt;</span>
00011   <span class="keyword">static</span> ofstream debugOut(<span class="stringliteral">"wrapexpat_debug.txt"</span>);
00012 <span class="preprocessor">  #define LOG_DEBUG(str) debugOut &lt;&lt; str &lt;&lt; endl;</span>
00013 <span class="preprocessor"></span><span class="preprocessor"> #else</span>
00014 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;iostream&gt;</span>
00015 <span class="preprocessor">  #define LOG_DEBUG(str) cout &lt;&lt; str &lt;&lt; endl;</span>
00016 <span class="preprocessor"></span><span class="preprocessor"> #endif</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00018 <span class="preprocessor"></span><span class="preprocessor"> #define LOG_DEBUG(str) {}</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif // LOG_DEBUG</span>
00021 <span class="preprocessor"></span>
00022 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00023 
00024 <span class="comment">// trim_right() family.</span>
00025 string Expat::trim_right ( <span class="keyword">const</span> string &amp; source, <span class="keyword">const</span> string &amp; t)
00026 {
00027     string str = source;
00028     <span class="keywordflow">return</span> str.erase ( str.find_last_not_of ( t ) + 1 ) ;
00029 }
00030 
00031 <span class="comment">// trim_left() family.</span>
00032 string Expat::trim_left ( <span class="keyword">const</span> string &amp; source, <span class="keyword">const</span> string &amp; t)
00033 {
00034     string str = source;
00035     <span class="keywordflow">return</span> str.erase ( 0 , source.find_first_not_of ( t ) ) ;
00036 }
00037 
00038 <span class="comment">// trim() family.</span>
00039 string Expat::trim ( <span class="keyword">const</span> string &amp; source, <span class="keyword">const</span> string &amp; t)
00040 {
00041     string str = source;
00042     <span class="keywordflow">return</span> trim_left ( trim_right ( str , t ) , t ) ;
00043 }
00044  
00045 Expat::Expat()
00046 {
00047     parser = 0;
00048     init();
00049 }
00050 
00051 Expat::~Expat()
00052 {
00053     cleanup();
00054 }
00055 
00056 <span class="keywordtype">void</span> Expat::init()
00057 {
00058     <span class="keywordflow">if</span> (parser != 0)
00059         cleanup();
00060 
00061     parser = XML_ParserCreate( NULL );
00062     XML_SetElementHandler(parser, startElement, endElement);
00063     XML_SetCharacterDataHandler(parser, charData);
00064     XML_SetUserData(parser, (<span class="keywordtype">void</span> *)<span class="keyword">this</span>);
00065 
00066     rootRecieved = <span class="keyword">false</span>;
00067 }
00068 
00069 <span class="keywordtype">void</span> Expat::cleanup()
00070 {
00071     <span class="keywordflow">if</span> (parser == 0)
00072         <span class="keywordflow">return</span>;
00073 
00074     XML_ParserFree( parser );
00075     parser = 0;
00076 
00077     newNodes.clear();
00078     <span class="keywordflow">while</span> (!fillingNodes.empty())
00079         fillingNodes.pop();
00080 }
00081 
<a name="l00082"></a><a class="code" href="class_expat.html#a3">00082</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#a3">Expat::reset</a>()
00083 {
00084     cleanup();
00085     init();
00086 }
00087 
<a name="l00088"></a><a class="code" href="class_expat.html#a2">00088</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#a2">Expat::parse</a>(string data)
00089 {
00090     <span class="keywordflow">if</span> (!parser)
00091     {
00092         <a class="code" href="class_expat.html#b3">parserError</a>(<span class="stringliteral">"Expat::parse: Internal error"</span>,0);
00093         <span class="keywordflow">return</span>;
00094     }
00095 
00096     <span class="keywordflow">if</span> (!XML_Parse( parser, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)data.c_str(), (<span class="keywordtype">long</span> <span class="keywordtype">int</span>)data.length(), <span class="keyword">false</span> ))
00097     {
00098         <a class="code" href="class_expat.html#b3">parserError</a>( XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
00099         <span class="keywordflow">return</span>;
00100     }
00101 
00102     <span class="comment">// Send out any new tags</span>
00103     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;newNodes.size();i++)
00104         <a class="code" href="class_expat.html#b0">recievedTag</a>(newNodes[i]);
00105 
00106     newNodes.clear();
00107 }
00108 
<a name="l00109"></a><a class="code" href="class_expat.html#b0">00109</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#b0">Expat::recievedTag</a>( <a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;n)
00110 {
00111     LOG_DEBUG(string(n).c_str());
00112 }
00113 
<a name="l00114"></a><a class="code" href="class_expat.html#b1">00114</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#b1">Expat::rootTagRecieved</a>(<a class="code" href="class_x_m_l_node.html">XMLNode</a> &amp;n)
00115 {
00116     string s(<span class="stringliteral">"Recieved root tag:"</span>);
00117     s += string(n);
00118     LOG_DEBUG(s.c_str());
00119 }
00120 
<a name="l00121"></a><a class="code" href="class_expat.html#b2">00121</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#b2">Expat::rootTagEnded</a>()
00122 {
00123     LOG_DEBUG(<span class="stringliteral">"Root tag ended."</span>);
00124 }
00125 
<a name="l00126"></a><a class="code" href="class_expat.html#b3">00126</a> <span class="keywordtype">void</span> <a class="code" href="class_expat.html#b3">Expat::parserError</a>(string errorMsg, <span class="keywordtype">int</span> line )
00127 {
00128     stringstream err;
00129     err &lt;&lt; <span class="stringliteral">"Expat parser error: "</span> &lt;&lt; errorMsg &lt;&lt; <span class="stringliteral">" at "</span>&lt;&lt; line;
00130     
00131     <span class="comment">// try to keep object in sane state after throw</span>
00132     <a class="code" href="class_expat.html#a3">reset</a>();
00133     <span class="keywordflow">throw</span> <a class="code" href="class_expat_1_1_parse_failure.html">ParseFailure</a>(err.str().c_str());
00134 }
00135 
00136 <span class="keywordtype">void</span> Expat::startElement(<span class="keywordtype">void</span> *userData, <span class="keyword">const</span> XML_Char *name, <span class="keyword">const</span> XML_Char **atts)
00137 {
00138     <span class="comment">/* get the userdata into a usable form */</span>
00139     <a class="code" href="class_expat.html">Expat</a> *me = (<a class="code" href="class_expat.html">Expat</a> *)userData;
00140 
00141     <span class="comment">/* New tag? Well...create one */</span>
00142     <a class="code" href="class_x_m_l_node.html">XMLNode</a> t;
00143 
00144     t.<a class="code" href="class_x_m_l_node.html#a20">setName</a>(name);
00145     <span class="comment">/* now put on it's parameters */</span>
00146     <span class="keywordtype">int</span> i=0;
00147 
00148     <span class="keywordflow">if</span> (atts != NULL)
00149     {
00150         <span class="keywordflow">while</span> (atts[i] != NULL)
00151         {
00152             t.<a class="code" href="class_x_m_l_node.html#a23">setProperty</a>(atts[i],atts[i+1]);
00153             i+=2;
00154         }
00155     }
00156 
00157 
00158     <span class="keywordflow">if</span>( !me-&gt;<a class="code" href="class_expat.html#r0">rootRecieved</a> )
00159     {
00160         <span class="comment">// This is the first tag...therefore the root tag.</span>
00161         me-&gt;<a class="code" href="class_expat.html#b1">rootTagRecieved</a>(t);
00162         me-&gt;<a class="code" href="class_expat.html#r0">rootRecieved</a> = <span class="keyword">true</span>;
00163         <span class="keywordflow">return</span>;
00164     }
00165 
00166     <span class="comment">/* Register it as a sub tag of the previous tag */</span>
00167     <span class="keywordflow">if</span> (!me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.empty())
00168         me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top().addChild(t);
00169 
00170     <span class="comment">/* push this node onto the stack */</span>
00171     me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.push( t );
00172 }
00173 
00174 <span class="keywordtype">void</span> Expat::endElement(<span class="keywordtype">void</span> *userData, <span class="keyword">const</span> XML_Char *)
00175 {
00176     <span class="comment">/* get the userdata into a usable form */</span>
00177     <a class="code" href="class_expat.html">Expat</a> *me = (<a class="code" href="class_expat.html">Expat</a> *)userData;
00178 
00179     <span class="keywordflow">if</span> (me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.empty())
00180     {
00181         <span class="comment">// If this is 0 then this is the end of the root tag...</span>
00182         me-&gt;<a class="code" href="class_expat.html#b2">rootTagEnded</a>();
00183         <span class="keywordflow">return</span>;
00184     }
00185 
00186     <span class="keywordflow">if</span> (me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.size() == 1)
00187     {
00188         <span class="comment">// We used to send them right out from here...but I found out something very nasty can</span>
00189         <span class="comment">// happen...suppose that the parser is deleted because of this node (login error...)</span>
00190         me-&gt;<a class="code" href="class_expat.html#r1">newNodes</a>.push_back(me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top());
00191 
00192         <span class="comment">// We do not delete the node becuse that job belongs to</span>
00193         <span class="comment">// whoever overrid the revieced tag</span>
00194     }
00195 
00196     me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top().setData(trim(me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top().data(),<span class="stringliteral">"\n\r\t "</span>));
00197 
00198     me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.pop();
00199 }
00200 
00201 <span class="keywordtype">void</span> Expat::charData(<span class="keywordtype">void</span> *userData, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> length)
00202 {
00203     <span class="comment">/* get the userdata into a usable form */</span>
00204     <a class="code" href="class_expat.html">Expat</a> *me = (<a class="code" href="class_expat.html">Expat</a> *)userData;
00205 
00206     <span class="keywordtype">char</span> *data;
00207     data = <span class="keyword">new</span> <span class="keywordtype">char</span>[length + 1];
00208     memcpy(data, s, length);
00209     data[length] = <span class="charliteral">'\0'</span>;
00210 
00211     <span class="keywordflow">if</span> (me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.empty())
00212     {
00213         <span class="keyword">delete</span> [] data;
00214         <span class="keywordflow">return</span>;
00215     }
00216     string newData = me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top().data()+data;
00217 
00218     me-&gt;<a class="code" href="class_expat.html#r2">fillingNodes</a>.top().setData(newData);
00219 
00220     <span class="keyword">delete</span>[] data;
00221 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 9 23:07:57 2004 for YardSale by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
